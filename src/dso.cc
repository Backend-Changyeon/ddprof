// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0. This product includes software
// developed at Datadog (https://www.datadoghq.com/). Copyright 2021-Present
// Datadog, Inc.

#include "dso.hpp"

#include "constants.hpp"
#include "ddprof_defs.hpp"
#include "logger.hpp"
#include "string_format.hpp"

#include <algorithm>
#include <string_view>

namespace ddprof {

constexpr std::string_view s_vdso_str = "[vdso]";
constexpr std::string_view s_vsyscall_str = "[vsyscall]";
constexpr std::string_view s_stack_str = "[stack]";
constexpr std::string_view s_heap_str = "[heap]";
// anon and empty are the same (one comes from perf, the other from proc maps)
constexpr std::string_view s_anon_str = "//anon";
constexpr std::string_view s_anon_2_str = "[anon";
constexpr std::string_view s_jsa_str = ".jsa";
constexpr std::string_view s_mem_fd_str = "/memfd";
// Example of these include : anon_inode:[perf_event]
constexpr std::string_view s_anon_inode_str = "anon_inode";
// dll should not be considered as elf files
constexpr std::string_view s_dll_str = ".dll";
// Example socket:[123456]
constexpr std::string_view s_socket_str = "socket";
// null elements
constexpr std::string_view s_dev_zero_str = "/dev/zero";
constexpr std::string_view s_dev_null_str = "/dev/null";
constexpr std::string_view s_dd_profiling_str = k_libdd_profiling_name;

// invalid element
Dso::Dso()
    : _pid(-1), _start(), _end(), _pgoff(), _filename(), _inode(),
      _type(dso::kUndef), _executable(false), _id(k_file_info_error) {}

Dso::Dso(pid_t pid, ElfAddress_t start, ElfAddress_t end, ElfAddress_t pgoff,
         std::string &&filename, bool executable, inode_t inode)
    : _pid(pid), _start(start), _end(end), _pgoff(pgoff), _filename(filename),
      _inode(inode), _type(dso::kStandard), _executable(executable),
      _id(k_file_info_undef) {
  // note that substr manages the case where len str < len vdso_str
  if (_filename.substr(0, s_vdso_str.length()) == s_vdso_str) {
    _type = dso::kVdso;
  } else if (_filename.substr(0, s_vsyscall_str.length()) == s_vsyscall_str) {
    _type = dso::kVsysCall;
  } else if (_filename.substr(0, s_stack_str.length()) == s_stack_str) {
    _type = dso::kStack;
  } else if (_filename.substr(0, s_heap_str.length()) == s_heap_str) {
    _type = dso::kHeap;
    // Safeguard against other types of files we would not handle
  } else if (_filename.empty() || _filename.starts_with(s_anon_str) ||
             _filename.starts_with(s_anon_inode_str) ||
             _filename.starts_with(s_anon_2_str) ||
             _filename.starts_with(s_dev_zero_str) ||
             _filename.starts_with(s_dev_null_str) ||
             _filename.starts_with(s_mem_fd_str)) {
    _type = dso::kAnon;
  } else if ( // ends with .jsa
      _filename.ends_with(s_jsa_str) || _filename.ends_with(s_dll_str)) {
    _type = dso::kRuntime;
  } else if (_filename.substr(0, s_socket_str.length()) == s_socket_str) {
    _type = dso::kSocket;
  } else if (_filename[0] == '[') {
    _type = dso::kUndef;
  } else if (is_jit_dump_str(_filename, pid)) {
    _type = dso::kJITDump;
  } else { // check if this standard dso matches our internal dd_profiling lib
    std::size_t pos = _filename.rfind('/');
    if (pos != std::string::npos &&
        _filename.substr(pos + 1, s_dd_profiling_str.length()) ==
            s_dd_profiling_str) {
      _type = dso::kDDProfiling;
    }
  }
}

// The string should end with: "jit-[0-9]+\\.dump"
// and the number should be the pid, however, in wholehost mode
// we don't have visibility on the namespace's PID value.
bool Dso::is_jit_dump_str(std::string_view file_path, pid_t pid) {
  const std::string_view prefix = "jit-";
  const std::string_view ext = ".dump";
  if (!file_path.ends_with(ext))
    return false;
  file_path = file_path.substr(0, file_path.size() - ext.size());
  auto pos = file_path.rfind('/');
  if (pos != std::string_view::npos) {
    file_path = file_path.substr(pos + 1);
  }
  if (!file_path.starts_with(prefix))
    return false;
  file_path = file_path.substr(prefix.size());
  return std::all_of(file_path.begin(), file_path.end(), [](char c) {
    return std::isdigit(static_cast<unsigned char>(c));
  });
}

std::string Dso::to_string() const {
  return string_format("PID[%d] %lx-%lx %lx (%s)(T-%s)(%c)(ID#%d)", _pid,
                       _start, _end, _pgoff, _filename.c_str(),
                       dso::dso_type_str(_type), _executable ? 'x' : '-', _id);
}

std::string Dso::format_filename() const {
  if (dso::has_relevant_path(_type)) {
    return _filename;
  } else {
    return dso::dso_type_str(_type);
  }
}

std::ostream &operator<<(std::ostream &os, const Dso &dso) {
  os << dso.to_string() << std::endl;
  return os;
}

// perf does not return the same sizes as proc maps
// Example :
// PID<1> 7f763019e000-7f76304ddfff (//anon)
// PID<1> 7f763019e000-7f76304de000 ()

bool Dso::adjust_same(const Dso &o) {
  if (_start != o._start) {
    return false;
  }
  if (_pgoff != o._pgoff) {
    return false;
  }
  if (_type != o._type) {
    return false;
  }
  // only compare filename if we are backed by real files
  if (_type == dso::kStandard &&
      (_filename != o._filename || _inode != o._inode)) {
    return false;
  }
  if (_executable != o._executable) {
    return false;
  }
  _end = o._end;
  return true;
}

bool Dso::intersects(const Dso &o) const {
  // Check order of points
  // Test that we have lowest-start <-> lowest-end  ... highiest-start
  if (_start < o._start) {
    // this Dso comes first check then it ends before the other
    if (_end < o._start) {
      return false;
    }
  } else if (o._end < _start) {
    // dso comes after, check that other ends before our start
    return false;
  }
  return true;
}

bool Dso::is_within(ElfAddress_t addr) const {
  return (addr >= _start) && (addr <= _end);
}

} // namespace ddprof
